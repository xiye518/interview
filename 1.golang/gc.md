## gc
#### 参考链接
* [Go GC 20 问](https://mp.weixin.qq.com/s/o2oMMh0PF5ZSoYD0XOBY2Q)
* [【译】 Golang 中的垃圾回收（一）](https://juejin.im/post/5d2825bff265da1b6836e8d4)
* [【译】 Golang 中的垃圾回收:Go Traces（二）](https://juejin.im/post/5d300d44f265da1bba593be5)
* [【译】 Golang 中的垃圾回收（三）:Go Pacing](https://juejin.im/post/5d4037aff265da03e523102f)
* [Golang 垃圾回收剖析](http://legendtkl.com/2017/04/28/golang-gc/)
* []()

## golang gc、三色标记、写屏障


go的垃圾回收，官方形容为：非分代， 非紧缩， 写屏障，三色并发标记清理算法。

非分代：不像java那样分为年轻代和老年代，滋润也没有minor和majo gc的区别

非紧缩：在垃圾回收之后不会进行内存整理以清除内存碎片

写屏障：在并发标记的过程中，如果应用程序修改了对象图，就可能出现标记遗漏的可能，写屏障是为了处理标记遗漏的问题。

三色：将GC中的对象按照搜索情况分成三种：

  1.黑色：对象在这次GC中已标记，且这个对象包含的子对象也已标记

 2.灰色：对象在这次GC中已标记，但这个对象包含的子对象未标记

  3.白色：对象在这次GC中未标记。

 并发：可以和应用程序在一定程度上并发执行。

标记清理：GC算法分为2步：

1.标记阶段找出要回收的对象

2.清理阶段回收未被标记的对象（要被回收的对象）


## STW触发的时间
一次GC有两次触发STW，一次是GC的开始阶段，主要是开启写屏障和辅助GC等操作 另外就是标记完成之后，重新扫描部分根对象，禁用写屏障

#### GC的触发条件
GC在满足一定条件后会被触发, 触发条件有以下几种:
* gcTriggerAlways: 强制触发GC
* gcTriggerHeap: 当前分配的内存达到一定值就触发GC
* gcTriggerTime: 当一定时间没有执行过GC就触发GC
* gcTriggerCycle: 要求启动新一轮的GC, 已启动则跳过, 手动触发GC的runtime.GC()会使用这个条件

#### 三色标记的过程
* 所有对象最开始都是白色。
* 从 root 开始找到所有可达对象，标记为灰色，放入待处理队列。
* 遍历灰色对象队列，将其引用对象标记为灰色放入待处理队列，自身标记为黑色。
* 处理完灰色对象队列，执行清扫工作。
