# 2.linux、操作系统知识

linux操作系统相关的知识要了解，进程、线程、僵尸进程、堆、栈，IPC（进程间通信），锁futex，用户态内核态，select、poll、epoll等io多路复用模型，常用的shell脚本，linux下开发调试、vim；

#### 参考博客：

* [进程间通信IPC (InterProcess Communication)](https://www.jianshu.com/p/c1015f5ffa74)
* [僵尸进程和孤儿进程有什么区别? - 地球的外星人君的回答 - 知乎](https://www.zhihu.com/question/26432067/answer/170712593)
* [写给大忙人看的操作系统](https://juejin.im/post/5e58905f6fb9a07caa270bb0)
* [简直不要太硬了！一文带你彻底理解文件系统](https://juejin.im/post/5e7aea03f265da57616abd46)
* [用户态和内核态的区别](https://blog.csdn.net/youngyoungla/article/details/53106671)
* [linux下进程的进程最大数、最大线程数、进程打开的文件数和ulimit命令修改硬件资源限制](https://blog.csdn.net/gatieme/article/details/51058797)
* [大话 Select、Poll、Epoll](https://cloud.tencent.com/developer/article/1005481)
* []()
* []()
* []()



## 一、进程、线程、协程的区别
```
1.进程是资源分配单位,线程是cpu调度单位；
2.进程拥有一个完整的资源平台，二线程只独享必不可少的资源，如寄存器和栈；
3.线程同样具有就绪、阻塞和执行三种基本状态，同样具有状态之间的转换关系；
4.线程能减少并发执行的时间和空间开销
- 线程的创建时间比进程短；
- 线程的终止时间比进程短；
- 统一进程内的线程切换时间比进程短；
- 由于同一进程的各线程间共享内存和文件资源，可直接进行不通过内核的通信
```

1.进程是“程序执行的一个实例” ，担当分配系统资源的实体。进程创建必须分配一个完整的独立地址空间。

2.线程是进程的一个执行流，独立执行它自己的程序代码；是操作系统能够进行运算调度的最小单位。

3.协程是轻量级的线程，一个进程可轻松创建数十万计的协程；协程是种更一般意义的程序组件，那你内存空间够大，创建多少个函数就可以随意控制

## 二、进程间通信IPC (InterProcess Communication)

###### 2.1 进程间通信的概念

每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为**进程间通信（IPC，InterProcess Communication）**

![img](https:////upload-images.jianshu.io/upload_images/1281379-76c95f147203c797.png?imageMogr2/auto-orient/strip|imageView2/2/w/222/format/webp)



###### 2.2 进程间通信的7种方式

```
1.管道/匿名管道(pipe) 管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道。 
2.有名管道(FIFO) 
3.信号(Signal)
4.消息(Message)队列 
5.共享内存(share memory) 
6.信号量(semaphore) 
7.套接字(socket)
```

## 三、linux操作系统cgroup、namespace隔离

## 四、用户态、内核态的区别

内核态：cpu可以访问内存的所有数据，包括外围设备，例如硬盘，网卡，cpu也可以将自己从一个程序切换到另一个程序。

用户态：只能受限的访问内存，且不允许访问外围设备，占用cpu的能力被剥夺，cpu资源可以被其他程序获取。

- 当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。
- 当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。

为什么要有用户态和内核态？

由于需要限制不同的程序之间的访问能力, 防止他们获取别的程序的内存数据, 或者获取外围设备的数据, 并发送到网络, CPU划分出两个权限等级 -- 用户态和内核态。

系统调用工作流程，在CPU中的实现称之为**陷阱指令**(Trap Instruction)

1. 用户态程序将一些数据值放在寄存器中, 或者使用参数创建一个堆栈(stack frame), 以此表明需要操作系统提供的服务.

2. 用户态程序执行陷阱指令

3. CPU切换到内核态, 并跳到位于内存指定位置的指令, 这些指令是操作系统的一部分, 他们具有内存保护, 不可被用户态程序访问

4. 这些指令称之为陷阱(trap)或者系统调用处理器(system call handler). 他们会读取程序放入内存的数据参数, 并执行程序请求的服务

5. 系统调用完成后, 操作系统会重置CPU为用户态并返回系统调用的结果

用户态切换到内核态的步骤主要包括：

   [1] 从当前进程的描述符中提取其内核栈的ss0及esp0信息。

   [2] 使用ss0和esp0指向的内核栈将当前进程的cs,eip,eflags,ss,esp信息保存起来，这个

   过程也完成了由用户栈到内核栈的切换过程，同时保存了被暂停执行的程序的下一

   条指令。

   [3] 将先前由中断向量检索得到的中断处理程序的cs,eip信息装入相应的寄存器，开始

   执行中断处理程序，这时就转到了内核态的程序执行了。

## 五、docker的隔离机制，
## 六、并行、并发区别：
 并行是指程序的运行状态，要有两个线程正在执行才能算是Parallelism；并发指程序的逻辑结构，Concurrency则只要有两个以上线程还在执行过程中即可。简单地说，Parallelism要在多核或者多处理器情况下才能做到，而Concurrency则不需要。


## 七、什么是缓冲区溢出？有什么危害？其原因是什么？

缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。

危害有以下两点：

* 程序崩溃，导致拒绝额服务
* 跳转并且执行一段恶意代码

造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入。

## 八、堆和栈的区别

**内存分配中的栈和堆**

先看百度百科中的内存堆栈介绍：

堆栈空间分配

> 栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。
>
> 堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。

堆栈缓存方式

> 栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放。
>
> 堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。

## 九、浅谈乐观锁与悲观锁

## 十、僵尸进程与孤儿进程

##### 什么是僵尸进程？

Unix进程模型中，进程是按照父进程产生子进程，子进程产生子子进程这样的方式创建出完成各项相互协作功能的进程的。当一个进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。如果父进程没有这么做的话，会产生什么后果呢？此时，子进程虽然已经退出了，但是在系统进程表中还为它保留了一些退出状态的信息，如果父进程一直不取得这些退出信息的话，这些进程表项就将一直被占用，此时，这些占着茅坑不拉屎的子进程就成为“僵尸进程”（zombie）。系统进程表是一项有限资源，如果系统进程表被僵尸进程耗尽的话，系统就可能无法创建新的进程。

##### 孤儿进程

孤儿进程是指这样一类进程：在进程还未退出之前，它的父进程就已经退出了，一个没有了父进程的子进程就是一个孤儿进程（orphan）。既然所有进程都必须在退出之后被wait()或waitpid()以释放其遗留在系统中的一些资源，那么应该由谁来处理孤儿进程的善后事宜呢？这个重任就落到了init进程身上，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。这样，当一个孤儿进程“凄凉地”结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。

```
cat /proc/sys/kernel/pid_max #（操作系统线程ID的最大值）系统支持的最大线程数
# root @ xiye in ~ [22:07:32] 
$ cat /proc/sys/kernel/pid_max
32768

我们可以使用ulimit -a查看我们系统的所有限制
```



## 十一、字节序，大端小端？

大端模式，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；这和我们的阅读习惯一致。

小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。

目前Intel的80x86系列芯片是唯一还在坚持使用小端的芯片，ARM芯片默认采用小端，但可以切换为大端；而MIPS等芯片要么采用全部大端的方式储存，要么提供选项支持大端——可以在大小端之间切换。另外，对于大小端的处理也和编译器的实现有关，在C语言中，默认是小端（但在一些对于单片机的实现中却是基于大端，比如Keil 51C），Java是平台无关的，默认是大端。在网络上传输数据普遍采用的都是大端。