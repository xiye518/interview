# 3.网络

OSI七层网络模型，http、tcp、udp，tcp握手挥手、滑动窗口、拥塞控制，更高级的http2.0、quic等的原理；

#### 参考资料
* [面试官，不要再问我三次握手和四次挥手](https://juejin.im/post/5d9c284b518825095879e7a5)
* [三次握手的误解与错误类比 (RFC793 解读)](https://www.v2ex.com/t/524599)
* [TCP建立连接为什么需要三次握手的一些回答整理](https://blog.csdn.net/chuxin126/article/details/78304177)
* [深度理解select、poll和epoll](https://blog.csdn.net/davidsguo008/article/details/73556811)
* [为什么 IPv6 难以取代 IPv4](https://draveness.me/whys-the-design-ipv6-replacing-ipv4/)
* 
* []()
* []()
* []()
* []()
* []()
* []()

#### 通信的本质
在通信会话中，传达一条信息至少要两步通信：A->B 的消息，B->A 的 ACK。如果多接触一些其他行业的通信流程，例如航空、铁路调度，就会明白这一点。
TCP 建联，本质上需要传递两条信息：A->B 的初始 SYN 号，B->A 的初始 SYN 号，那么理论上需要四步通信（ A->B 的初始 SYN 号，B->A 的 ACK ； B->A 的初始 SYN 号，A->B 的 ACK ）；只不过为了效率和性能，中间两条消息可以合并为一条，这便是现在的三路握手的来源。后续的所有报文，本质上都是信息+ACK，和消息合并。

#### tcp握手协议分析
* TCP 的可靠连接是靠 seq （ sequence numbers 序列号）来达成的

* TCP 需要 seq 序列号来做可靠重传或接收，而避免连接复用时无法分辨出 seq 是延迟或者是旧链接的 seq，因此需要三次握手来约定确定双方的 ISN （初始 seq 序列号）。

* TCP 设计中一个基本设定就是，通过 TCP 连接发送的每一个包，都有一个 sequence number。而因为每个包都是有序列号的，所以都能被确认收到这些包。

* 确认机制是累计的，所以一个对 sequence number X 的确认，意味着 X 序列号之前(不包括 X) 包都是被确认接收到的。

* TCP 协议是不限制一个特定的连接（两端 socket 一样）被重复使用的。

* 所以这样就有一个问题：这条连接突然断开重连后，TCP 怎么样识别之前旧链接重发的包？——这就需要独一无二的 ISN （初始序列号）机制。

 three way handshake ）是必须的， 因为 sequence numbers （序列号）没有绑定到整个网络的全局时钟（全部统一使用一个时钟，就可以确定这个包是不是延迟到的）以及 TCPs 可能有不同的机制来选择 ISN （初始序列号）。

接收方接收到第一个 SYN 时，没有办法知道这个 SYN 是是否延迟了很久了，除非他有办法记住在这条连接中，最后接收到的那个 sequence numbers （然而这不总是可行的）。
这句话的意思是：一个 seq 过来了，跟现在记住的 seq 不一样，我怎么知道他是上条延迟的，还是上上条延迟的呢？
所以，接收方一定需要跟发送方确认 SYN。
假设不确认 SYN 中的 SEQ，那么就只有：
```
A --> B SYN my sequence number is X
A <-- B ACK your sequence number is X SYN my sequence number is Y
```
只有 B 确认了收到了 A 的 SEQ，A 无法确认收到 B 的。也就是说，只有 A 发送给 B 的包都是可靠的， 而 B 发送给 A 的则不是，所以这不是可靠的连接。这种情况如果只需要 A 发送给 B，B 无需回应，则可以不做三次握手。

```
三次握手详细过程
      TCP A                                                TCP B

  1.  CLOSED                                               LISTEN

  2.  SYN-SENT    --> <SEQ=100><CTL=SYN>               --> SYN-RECEIVED

  3.  ESTABLISHED <-- <SEQ=300><ACK=101><CTL=SYN,ACK>  <-- SYN-RECEIVED

  4.  ESTABLISHED --> <SEQ=101><ACK=301><CTL=ACK>       --> ESTABLISHED

  5.  ESTABLISHED --> <SEQ=101><ACK=301><CTL=ACK><DATA> --> ESTABLISHED

          Basic 3-Way Handshake for Connection Synchronization

                                Figure 7.
```
在上图

> 第二行中，A 发送了 SEQ 100，标志位是 SYN ；

> 第三行，B 发回了 ACK 101 与 SEQ 300，标志位是 SYN 与 ACK （两个过程合并了）。注意，ACK 是 101 意味着，B 希望接收到 101 序列号开始的数据段。

> 第四行，A 返回了空的数据，SEQ 101，ACK 301，标志位为 ACK。至此，双方的开始 SEQ （也就是 ISN ）号 100 与 300 都被确认接收到了。

> 第五行，开始正式发送数据包，注意的是 ACK 依旧是第四行的 301，因为没有需要 ACK 的 SYN 了（第四行已经 ACK 完）。


在Google Groups的TopLanguage中看到一帖讨论TCP“三次握手”觉得很有意思。贴主提出“TCP建立连接为什么是三次握手？”的问题，在众多回复中，有一条回复写道：“这个问题的本质是, 信道不可靠, 但是通信双发需要就某个问题达成一致. 而要解决这个问题, 无论你在消息中包含什么信息, 三次通信是理论上的最小值. 所以三次握手不是TCP本身的要求, 而是为了满足"在不可靠信道上可靠地传输信息"这一需求所导致的. 请注意这里的本质需求,信道不可靠, 数据传输要可靠. 三次达到了, 那后面你想接着握手也好, 发数据也好, 跟进行可靠信息传输的需求就没关系了. 因此,如果信道是可靠的, 即无论什么时候发出消息, 对方一定能收到, 或者你不关心是否要保证对方收到你的消息, 那就能像UDP那样直接发送消息就可以了.”。这可视为对“三次握手”目的的另一种解答思路。


## tcp、udp的区别
tcp/udp在模型的传输层
自下而上网络接口层、网际层（ip/ARP/icmp/igmp/rarp）、传输层（tcp/udp）、应用层
      物理层/数据链路层、网络层、传输层、会话层/表示层/应用层

udp：面向无连接的通信协议，数据包括目的端口信息和源端口信息
优点：面向无连接，操作简单，要求系统资源较少，速度快，由于不需要连接，可进行广播发送
缺点：发送数据之前不需要与对方建立连接，接收到数据时也不需要发送确认信号，发送端不知道接收端是否正确接接收，不会重发，不可靠。
tcp：面向连接的通讯协议，通过三次握手建立连接，通讯完成时四次挥手断开连接
优点：在数据传输时，有确认、窗口、重传、拥塞控制机制，能保证数据正确性，较为可靠
缺点：速度相对慢一点，要求系统资源较多

tcp短连接：client向server发起连接，server接到请求，双方建立连接，client向server发送消息，server回应client，一次读写完成双方都可以发起close请求
tcp长连接：client向server发起连接，server接到请求，双方建立连接，client向server发送消息，server回应client，一次读写完成，连接不关闭，后续读写操作，长时间操作之后client发起关闭请求。
tcp长连接优缺点：长连接可以省去较多的tcp建立/关闭的操作，减少浪费，节省时间，对于频繁请求资源的客户，较适用于长连接；client和server如果长时间不关闭的话，会存在一个问题，随着客户的越来越多，server早晚会有扛不住的一天，这时需要采取一些策略，如关闭一些长时间不读写操作的连接，这样可以避免一些恶意连接导致server端服务受损，如果条件再允许，就可以以客户端为颗粒度，限制每个客户端的最大连接数，
tcp短连接优缺点：短连接对于服务器来说较为简单，存在的连接都是有用的连接，不需要额外的控制，但如果客户端连接频繁，会在tcp的建立和关闭上浪费时间。

-----------------------

小结TCP与UDP的区别：
1、基于连接与无连接；

2、对系统资源的要求（TCP较多，UDP少）；

3、UDP程序结构较简单；

4、流模式与数据报模式 ；

5、TCP保证数据正确性，UDP可能丢包；

6、TCP保证数据顺序，UDP不保证。
* [TCP和UDP的区别](https://zhuanlan.zhihu.com/p/24860273)

## 为啥要用proterbuf、msgpack
msgpack和protobuf的对比

msgpack的序列化速度比protobuf要快一些，但反序列化要比protobuf要慢一些，但总体都接近
msgpack可以直接序列化类对象，但protobuf需要先写描述映射文件(.proto)
msgpack支持的基本类型比protobuf支持的要全面些
protobuf的描述文件无法实现类的继承（不知V2.0以上会如何）
然而，msgpack在unity下的ios与wp平台下无法支持，但protobuf可以支持全平台

* (JSON、Protobuf、Thrift、MessagePack 对比和开发指南)[https://blog.51cto.com/13952501/2173038]
* (移动场景下通信协议FlatBuffers、ProtocolBuffers、MessagePack选优)[http://www.cocoachina.com/articles/22353]


## jwt协议
* ()[]

## gin、beego网络框架
* ()[]

## http 302状态码
官方的比较简洁的说明：

        301 redirect: 301 代表永久性转移(Permanently Moved)
        302 redirect: 302 代表暂时性转移(Temporarily Moved )

 详细来说，301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）——这是它们的共同点。他们的不同在于。301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。

#### 1、什么是重定向啊？

    就是地址A跳转到地址B啦。百度百科的解释：重定向(Redirect)就是通过各种方法将各种网络请求重新定个方向转到其它位置（如：网页重定向、域名的重定向、路由选择的变化也是对数据报文经由路径的一种重定向）。

#### 2、可是，为什么要进行重定向啊？什么时候需要重定向呢？
还是借鉴百度百科：

* 1）网站调整（如改变网页目录结构）；
* 2）网页被移到一个新地址；
* 3）网页扩展名改变(如应用需要把.php改成.Html或.shtml)。

        这种情况下，如果不做重定向，则用户收藏夹或搜索引擎数据库中旧地址只能让访问客户得到一个404页面错误信息，访问流量白白丧失；再者某些注册了多个域名的网站，也需要通过重定向让访问这些域名的用户自动跳转到主站点等。

* (http状态码301和302详解及区别——辛酸的探索之路)[https://blog.csdn.net/grandPang/article/details/47448395]

## rpc底层协议是什么  socket？
## grpc和http协议的区别，grpc对比http有哪些优缺
## HTTP连接
HTTP协议即超文本传送协议(Hypertext Transfer Protocol )，是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。
HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。
* 1）在HTTP 1.0中，客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。

* 2）在HTTP 1.1中则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。

由于HTTP在每次请求结束后都会主动释放连接，因此HTTP连接是一种“短连接”，要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。通常 的做法是即时不需要获得任何数据，客户端也保持每隔一段固定的时间向服务器发送一次“保持连接”的请求，服务器在收到该请求后对客户端进行回复，表明知道 客户端“在线”。若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开。
点

## SOCKET原理
#### 套接字（socket）概念
套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。
应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个 TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应 用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。

#### 建立socket连接
建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ，另一个运行于服务器端，称为ServerSocket 。
套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。
服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。
客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。
连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发 给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。

#### SOCKET连接与TCP连接
创建Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。

#### Socket连接与HTTP连接
由于通常情况下Socket连接就是TCP连接，因此Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际网 络应用中，客户端到服务器之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。
而HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。
很多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。此时若双方建立的是Socket连接，服务器就可以直接将数 据传送给客户端；若双方建立的是HTTP连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，因此，客户端定时向服务器端发送连接请求， 不仅可以保持在线，同时也是在“询问”服务器是否有新的数据，如果有就将数据传给客户端。

## TCP(Transmission Control Protocol)　传输控制协议

TCP是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接:

位码即tcp标志位,有6种标示:SYN(synchronous建立联机) ACK(acknowledgement 确认) PSH(push传送) FIN(finish结束) RST(reset重置) URG(urgent紧急)
Sequence number(顺序号码) Acknowledge number(确认号码)

   

TCP是什么？
TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。

* [TCP是什么？](https://github.com/jawil/blog/issues/14)


## 长连接短连接的区别？各自的优缺点？使用场景
####  长连接和短连接的优点和缺点
长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。对于频繁请求资源的客户来说，较适用长连接。不过这里存在一个问题，存活功能的探测周期太长，还有就是它只是探测TCP连接的存活，属于比较斯文的做法，遇到恶意的连接时，保活功能就不够使了。在长连接的应用场景下，client端一般不会主动关闭它们之间的连接，Client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可 以避免一些恶意连接导致server端服务受损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个蛋疼的客户端连累后端服务。

短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户请求频繁，将在TCP的建立和关闭操作上浪费时间和带宽。

长连接和短连接的产生在于client和server采取的关闭策略，具体的应用场景采用具体的策略，没有十全十美的选择，只有合适的选择。

#### 什么时候用长连接，短连接？
长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况，。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。

而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。

## http和https的区别
HTTPS和HTTP的区别主要如下：

1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。

2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。

3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

* [详细解析 HTTP 与 HTTPS 的区别](https://juejin.im/entry/58d7635e5c497d0057fae036)


## 大小端模式
大端模式，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；这和我们的阅读习惯一致。

小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。

目前Intel的80x86系列芯片是唯一还在坚持使用小端的芯片，ARM芯片默认采用小端，但可以切换为大端；而MIPS等芯片要么采用全部大端的方式储存，要么提供选项支持大端——可以在大小端之间切换。另外，对于大小端的处理也和编译器的实现有关，在C语言中，默认是小端（但在一些对于单片机的实现中却是基于大端，比如Keil 51C），Java是平台无关的，默认是大端。在网络上传输数据普遍采用的都是大端。


## 浏览器输入url，发生了什么
总的来说，当你输入在浏览器里输入一个URL到页面加载，发生的顺序如下：

* 1.DNS查询
* 2.TCP连接
* 3.发送HTTP请求
* 4.Server处理HTTP请求并返回HTTP报文
* 5.浏览器解析并render页面
* 6.HTTP连接断开


## 更多关于close和shutdown的说明：
* 1. 如果有多个进程共享一个套接字，close每被调用一次，计数减1，直到计数为0时，也就是所用进程都调用了close，套接字将被释放。
* 2. 在多进程中如果一个进程中shutdown(sfd, SHUT_RDWR)后其它的进程将无法进行通信. 如果一个进程close(sfd)将不会影响到其它进程. 得自己理解引用计数的用法了. 有Kernel编程知识的更好理解了.
* 3. 只要TCP栈的读缓冲里还有未读取（read）数据，则调用close时会直接向对端发送RST。
* 4. shutdown与socket描述符没有关系，即使调用shutdown(fd, SHUT_RDWR)也不会关闭fd，最终还需close(fd)。
* 5. 可以认为shutdown(fd, SHUT_RD)是空操作，因为shutdown后还可以继续从该socket读取数据，这点也许还需要进一步证实。
* 6. 在已发送FIN包后write该socket描述符会引发EPIPE/SIGPIPE。
* 7. 当有多个socket描述符指向同一socket对象时，调用close时首先会递减该对象的引用计数，计数为0时才会发送FIN包结束TCP连接。shutdown不同，只要以SHUT_WR/SHUT_RDWR方式调用即发送FIN包。
* 8. SO_LINGER与close，当SO_LINGER选项开启但超时值为0时，调用close直接发送RST（这样可以避免进入TIME_WAIT状态，但破坏了TCP协议的正常工作方式），SO_LINGER对shutdown无影响。
* 9. TCP连接上出现RST与随后可能的TIME_WAIT状态没有直接关系，主动发FIN包方必然会进入TIME_WAIT状态，除非不发送FIN而直接以发送RST结束连接。




