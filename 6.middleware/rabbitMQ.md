# rabbitMQ
[RabbitMq的整理 exchange、route、queue关系](https://blog.csdn.net/samxx8/article/details/47417133)

[一篇全面透彻的RabbitMQ指南！](https://juejin.im/entry/599e5e3b5188252437799049)

从AMQP协议可以看出，MessageQueue、Exchange和Binding构成了AMQP协议的核心

* Broker：简单来说就是消息队列服务器实体。
* Exchange：消息交换机，它指定消息按什么规则，路由到哪个队列。
* Queue：消息队列载体，每个消息都会被投入到一个或多个队列。
* Binding：绑定，它的作用就是把exchange和queue按照路由规则绑定起来。
* Routing Key：路由关键字，exchange根据这个关键字进行消息投递。
* vhost：虚拟主机，一个broker里可以开设多个vhost，用作不同用户的权限分离。
* producer：消息生产者，就是投递消息的程序。
* consumer：消息消费者，就是接受消息的程序。
* channel：消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务。

消息队列的使用过程大概如下：

* （1）客户端连接到消息队列服务器，打开一个channel。
* （2）客户端声明一个exchange，并设置相关属性。
* （3）客户端声明一个queue，并设置相关属性。
* （4）客户端使用routing key，在exchange和queue之间建立好绑定关系。
* （5）客户端投递消息到exchange。

## 一、基础概念
* RabbitMQ本身安装部署（单实例/集群）均较为简单，上手门槛低，功能丰富，符合AMQP标准
* RabbitMQ的集群易于扩缩，可以根据实际的业务访问量，通过增减集群中节点实例的方式，达到弹性扩容、缩小的效果
* 企业级消息队列中间件，经过业界各个公司生产环境大量实践案例的验证，具有较高的可靠性
* RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker 的许多方面，如果消息异常，RabbitMQ 提供了消息跟踪机制，使用者可以找出发生了什么。
* 支持消息持久化、支持消息确认机制、灵活的任务分发机制等，支持功能非常丰富
* 实现高可用性，可以在RabbitMQ集群中的机器上创建队列的镜像，使得在部分节点出问题的情况下队列仍然可用。

## 二、通信过程
* 1、消息生产者连接到RabbitMQ Broker，创建connection，开启channel。
* 2、生产者声明交换机类型、名称、是否持久化等（其实这个说法不是很准确，其实大部分是在管理页面或者消费者端先声明的）。
* 3、生产者发送消息，并指定消息是否持久化等属性和routing key。
* 4、exchange收到消息之后，根据routing key路由到跟当前交换机绑定的相匹配的队列里面。
* 5、消费者监听接收到消息之后开始业务处理，然后发送一个ack确认告知消息已经被消费（手动自动都有可能）。
* 6、RabbitMQ Broker收到ack之后将对应的消息从队列里面删除掉。

## 三、消息路由模式
####  1、直接模式（Direct）

  消息中的路由键（routing key）如果和 Binding 中的 binding key 一致， 交换器就将消息发到对应的队列中。直接模式是一对一的、单播的模式。
  
  这种模式下不需要将Exchange进行任何绑定(binding)操作，消息传递时需要一个“RoutingKey”，可以简单的理解为要发送到的队列名字。但是如果vhost中不存在RoutingKey中指定的队列名，则该消息会被抛弃 。

####  2、广播模式（Fanout）

  Fanout交换器不处理路由键，只是简单的将队列绑定到交换器上，每个发送到交换器的消息都会被转发到与该交换器绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。所以Fanout 类型转发消息是最快的。

  广播模式模式不需要RoutingKey，只需要提前将Exchange与Queue进行绑定，一个Exchange可以绑定多个Queue，一个Queue可以同多个Exchange进行绑定。但是如果接受到消息的Exchange没有与任何Queue绑定，则消息会被抛弃。

  但是因为转发到全部绑定的队列上，所以广播模式存在重复消费的问题。
  
#### 3、主题模式（Topic）
  
  任何发送到Topic Exchange的消息都会被转发到所有关心RouteKey中指定话题的Queue上
  
  每个队列都有其关心的主题，所有的消息都带有一个“标题”(RoutingKey路由键)，Exchange会将消息转发到所有关注主题能与RoutingKey模糊匹配的队列。主题模式需要RoutingKey，也需要提前绑定Exchange与Queue，在进行绑定时，要提供一个该队列关心的主题。Topic模式有两个关键词#和*。
  
    * “#”表示0个或若干个关键字，如“#.nanju.#”表示该队列关心所有涉及nanju的消息(一个RoutingKey为”asd.MQ.nanju.error”的消息会被转发到该队列)，
    * *表示一个关键字息，如“*.nanju.*”(一个RoutingKey为”asd.nanju.error”的消息会被转发到该队列，而”asd.MQ.nanju.error”则不会)
  
  同样，如果Exchange没有发现能够与RoutingKey匹配的Queue，则会抛弃此消息。


## 四、工作模式
#### 1、简单模式：一个生产者，一个消费者
  流程：
  
  1、生产者将消息放入消息队列
  2、消息的消费者监听消息队列,如果队列中有消息,就消费掉。消息被消费之后,自动从队列中删除(容易出现消息还没有被消费者正确处理,已经从队列中消失了,造成消息的丢失)

适合场景：

* 简单的聊天系统

#### 2、work模式：一个生产者，多个消费者，每个消费者获取到的消息唯一
流程：

* 1、生产者将消息放入消息队列
* 多个消息的消费者同时监听消息队列内容,谁先拿到谁负责消费消息(高并发情况下,默认会产生某一个消息被多个消费者共同使用,可以设置一个开关，保证一条消息只能被一个消费者使用)

适合场景：

* 抢红包
* 随机分派任务

#### 3、订阅模式：一个生产者发送的消息会被多个消费者获取
流程：

* 1、消息产生者将消息放入交换机
* 2、交换机发布订阅把消息发送到所有消息队列中,对应消息队列的消费者拿到消息进行消费
适合场景：

* 邮件下发
* 场景订阅
* 短信下发

#### 4、路由模式：发送消息到交换机并且要指定路由key ，消费者将队列绑定到交换机时需要指定路由key
流程：

* 1、消息生产者将消息发送给交换机
* 2、交换机根据Routing key,只能匹配上Routing key对应的消息队列,对应的消费者才能消费消息;

路由模式和订阅模式比较相似，只是路由模式模式要求队列在绑定交换机时要指定Routing key，消息会转发到符合Routing key的队列。
适合场景:

* 邮件下发
* 场景订阅
* 短信下发

#### 5、主题模式：将路由键和某模式进行匹配，此时队列需要绑定在一个模式上，“#”匹配一个词或多个词，“*”只匹配一个词
流程：

* 1、消息产生者产生消息,把消息交给交换机
* 2、交换机根据key的规则模糊匹配到对应的队列,由队列的监听消费者接收消息消费，每个消费者监听自己的队列，并且设置带统配符的routingkey

适合场景：

* 用户通知的各种情况


