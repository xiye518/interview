# 3.中间件--MQ
* [【进阶之路】消息队列——原理及选型（一）](https://juejin.im/post/5e8e8c2be51d4546fa4525b5)
* [【进阶之路】消息队列——RabbitMQ原理（二）](https://juejin.im/post/5e916e2fe51d4546bd3501f1)

* [关于MQ的几件小事（一）消息队列的用途、优缺点、技术选型](https://juejin.im/post/5ce55db3f265da1bb27706fe)
* [关于MQ的几件小事（二）如何保证消息队列的高可用](https://juejin.im/post/5ce55e0af265da1b667bb22c)
* [关于MQ的几件小事（三）如何保证消息不重复消费](https://juejin.im/post/5ce55e9d51882521ee5fc3ff)
* [关于MQ的几件小事（四）如何保证消息不丢失](https://juejin.im/post/5ce55f0ff265da1b6a346b60)
* [关于MQ的几件小事（五）如何保证消息按顺序执行](https://juejin.im/post/5ce560195188253114078ae0)
* [关于MQ的几件小事（六）消息积压在消息队列里怎么办](https://juejin.im/post/5ce5607e518825240245bf66)
* [关于MQ的几件小事（七）如果让你设计一个MQ，你怎么设计](https://juejin.im/post/5ce561135188250bb3719a16)
* []()

## 一.什么时候需要消息队列
* 异步处理：处理如短信下发、状态推送、用户注册、数据同步等功能，提高系统的并发能力，集中力量处理重要的部分（同步处理），将非核心功能丢给MQ。
* 系统解耦：可在模块、服务、接口等不同粒度上实现解耦。
* 重试补偿：在跨机器数据传输的整个过程中，只要任意一个环节出错，都会导致问题的产生。可以通过MQ的重试补偿机制去尽可能的处理掉这些异常。
* 流量削锋：对于秒杀场景下的下单处理。服务器收到消息后，首先写入消息队列，然后按照自己的消息处理能力做处理。
* 日志处理：可以定时将日志写入MQ，并且主动订阅日志记录。

## 二、消息队列核心概念
     1、消息服务器Broker：消息服务器，作为server提供消息核心服务
     2、消息生产者Producer：发送消息到消息队列。
     3、消息消费者Consumer：从消息队列接收消息。
     4、消息队列Queue：一个先进先出的消息存储区域。消息按照顺序发送接收，一旦消息被消费处理，该消息将从队列中删除。
     5、主题Topic：主题，发布订阅模式下的消息统一汇集地，不同生产者向topic发送消息，由MQ服
     务器分发到不同的订阅者，实现消息的消费
     6、消息体Message

## 三、消息模式
  *  1、PTP点对点
   
   特点：
   
    * 每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在消息队列中)
    * 发送者和接收者之间在时间上没有依赖性
    * 接收者在成功接收消息之后需向队列应答成功
    * 利用FIFO先进先出的特性，可以保证消息的顺序性。
   
  * 2、Pub/Sub发布订阅
   
特点：

    * 每个消息可以有多个消费者：和点对点方式不同，发布消息可以被所有订阅者消费
    * 发布者和订阅者之间有时间上的依赖性。
    * 针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息。
    * 为了消费消息，订阅者必须保持运行的状态。

## 四、常用协议
   * AMQP
   * STOMP
   * XMPP
   * JMS
     




## 关于MQ的几件小事（七）如果让你设计一个MQ，你怎么设计
其实回答这类问题，说白了，起码不求你看过那技术的源码，起码你大概知道那个技术的基本原理，核心组成部分，基本架构构成，然后参照一些开源的技术把一个系统设计出来的思路说一下就好

比如说这个消息队列系统，我们来从以下几个角度来考虑一下

（1）首先这个mq得支持可伸缩性吧，就是需要的时候快速扩容，就可以增加吞吐量和容量，那怎么搞？设计个分布式的系统呗，参照一下kafka的设计理念，broker -> topic -> partition，每个partition放一个机器，就存一部分数据。如果现在资源不够了，简单啊，给topic增加partition，然后做数据迁移，增加机器，不就可以存放更多数据，提供更高的吞吐量了？

（2）其次你得考虑一下这个mq的数据要不要落地磁盘吧？那肯定要了，落磁盘，才能保证别进程挂了数据就丢了。那落磁盘的时候怎么落啊？顺序写，这样就没有磁盘随机读写的寻址开销，磁盘顺序读写的性能是很高的，这就是kafka的思路。

（3）其次你考虑一下你的mq的可用性啊？这个事儿，具体参考我们之前可用性那个环节讲解的kafka的高可用保障机制。多副本 -> leader & follower -> broker挂了重新选举leader即可对外服务。

（4）能不能支持数据0丢失啊？可以的，参考我们之前说的那个kafka数据零丢失方案

其实一个mq肯定是很复杂的，其实这是个开放题，就是看看你有没有从架构角度整体构思和设计的思维以及能力。




