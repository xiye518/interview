## 跳表
* [跳表──没听过但很犀利的数据结构](https://lotabout.me/2018/skip-list/)
* [漫画：什么是跳表？](https://zhuanlan.zhihu.com/p/53975333)
* [Golang实践----跳表](https://studygolang.com/articles/21630)
* [redis zset 内部的实现原理](https://blog.csdn.net/weixin_38008100/article/details/94629753)
* []()

跳表(skip list) 对标的是平衡树(AVL Tree)，是一种 插入/删除/搜索 都是 O(log n) 的数据结构。它最大的优势是原理简单、容易实现、方便扩展、效率更高。因此在一些热门的项目里用来替代平衡树，如 redis, leveldb 等。

> * 各种搜索结构提高效率的方式都是通过空间换时间得到的。
> * 跳表最终形成的结构和搜索树很相似。
> * 跳表通过随机的方式来决定新插入节点来决定索引的层数。
> * 跳表搜索的时间复杂度是 O(logn)，插入/删除也是。

#### 跳表插入
* 1.新节点和各层索引节点逐一比较，确定原链表的插入位置。O（logN）
* 2.把索引插入到原链表。O（1）
* 3.利用抛硬币的随机方式，决定新节点是否提升为上一级索引。结果为“正”则提升并继续抛硬币，结果为“负”则停止。O（logN）

总体上，跳跃表插入操作的时间复杂度是O（logN），而这种数据结构所占空间是2N，既空间复杂度是 O（N）。

#### 跳表删除
* 1.自上而下，查找第一次出现节点的索引，并逐层找到每一层对应的节点。O（logN）
* 2.删除每一层查找到的节点，如果该层只剩下1个节点，删除整个一层（原链表除外）。O（logN）

总体上，跳跃表删除操作的时间复杂度是O（logN）。

## 跳跃表和二叉查找树的区别？
跳跃表的优点是维持结构平衡的成本比较低，完全依靠随机。而二叉查找树在多次插入删除后，需要Rebalance来重新调整结构平衡

所以说没有绝对优劣的数据结构，关键要看应用场景

redis的有序集合`sorted-set`就是对跳表的改进和应用

### skiplist与平衡树、哈希表的比较

- skiplist和各种平衡树（如AVL、红黑树等）的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个key的查找，不适宜做范围查找。所谓范围查找，指的是查找那些大小在指定的两个值之间的所有节点。
- 在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。
- 平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。
- 从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。
- 查找单个key，skiplist和平衡树的时间复杂度都为O(log n)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。
- 从算法实现难度上来比较，skiplist比平衡树要简单得多。